# ECE264

    Explain how the call stack changes as a program progresses
        Understand how local variables and arguments appear on call stack in function codes
        Understand how call stack grows when a function called
        Understand how call stack shrinks when a function completes
        Understand where the program continues after a function completes
        Understand pointers
            Distinguish the meaning of the pointer in four different context
            Apply pointers in appropriate context
    Implement algorithms using C
        Describe an algorithm in English
            Describe the assumptions and restrictions of the problem
            Describe the input of the algorithm
            Describe the desired outcome of the algorithm
            Describe the procedure to produce the desired outcome from the input
        Generate scenarios to validate the algorithm
            Describe all valid scenarios that can be handled by the algorithm
            Identify at least three invalid scenarios which cannot be handled by the algorithm
        Translate an algorithm from English to a C program
            Choose appropriate library functions when translating an algorithm
            Utilize online manual of library functions and distinguish between related functions
            Convert the procedure in English to appropriate syntax in the C program
        Create test cases to verify the program
            Differentiate between correct and incorrect results when testing a program
            Understand the functionalities of various tools for testing and debugging
            Utilize appropriate tools in testing
            Interpret the results from testing and take appropriate action for correcting the program
    Write programs that use recursion
        Explain the terminating condition(s) of recursion
        Describe the solution for a complex case based on the solutions of simpler cases
        Translate a recursive solution from English to a C program
    Manage memory
        Distinguish between memory using call stack or heap
        Understand call stack is managed by compiler
        Understand heap memory is managed by programmer
        Identify the conditions when dynamic memory allocation and release are required
        Utilize appropriate tools to detect inappropriate memory usage
    Create new data types that can be dynamically allocated or released
        Understand the purpose of new data types and how to create new data types
        Define self-referring data types for recording data of unknown size
        Describe algorithms using self-referring data types
        Distinguish between data types with different time and space efficiency
        Implement the algorithms in C programs
    Develop the ability to read program specifications and documentations
        Understand the requirements in a specification
        Identify incomplete or inconsistent requirements in a specification
        Make appropriate decisions in interpreting specifications and clearly document the decisions
        Look up references for the C language
